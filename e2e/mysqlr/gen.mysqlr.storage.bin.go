// Package mysqlr is generated by ezorm (v2)
// DO NOT EDIT
package mysqlr

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/ezbuy/ezorm/v2/pkg/orm"

	validator "gopkg.in/go-playground/validator.v9"
)

var (
	_ sql.DB
	_ time.Time
	_ fmt.Formatter
	_ strings.Reader
	_ validator.Validate
	_ context.Context
)

type StorageBin struct {
	Id                int64  `mysql:"id"`
	TypeId            int64  `mysql:"type_id"`
	Code              string `mysql:"code"`
	State             int32  `mysql:"state"`
	WarehouseId       int64  `mysql:"warehouse_id"`
	RegionId          int64  `mysql:"region_id"`
	AreaId            int64  `mysql:"area_id"`
	Aisle             int32  `mysql:"aisle"`
	RackRow           int32  `mysql:"rack_row"`
	RackCol           int32  `mysql:"rack_col"`
	CapacityPreempted int64  `mysql:"capacity_preempted"`
	CapacityOccupied  int64  `mysql:"capacity_occupied"`
	CapacityLock      int64  `mysql:"capacity_lock"`
	CreateAt          int64  `mysql:"create_at"`
	UpdateAt          int64  `mysql:"update_at"`
	CreateBy          string `mysql:"create_by"`
	UpdateBy          string `mysql:"update_by"`
}

var StorageBinColumns = struct {
	Id                string
	TypeId            string
	Code              string
	State             string
	WarehouseId       string
	RegionId          string
	AreaId            string
	Aisle             string
	RackRow           string
	RackCol           string
	CapacityPreempted string
	CapacityOccupied  string
	CapacityLock      string
	CreateAt          string
	UpdateAt          string
	CreateBy          string
	UpdateBy          string
}{
	"id",
	"type_id",
	"code",
	"state",
	"warehouse_id",
	"region_id",
	"area_id",
	"aisle",
	"rack_row",
	"rack_col",
	"capacity_preempted",
	"capacity_occupied",
	"capacity_lock",
	"create_at",
	"update_at",
	"create_by",
	"update_by",
}

type _StorageBinMgr struct {
}

var StorageBinMgr *_StorageBinMgr

func (m *_StorageBinMgr) NewStorageBin() *StorageBin {
	return &StorageBin{}
}

func (obj *StorageBin) GetNameSpace() string {
	return "mysqlr_e2e"
}

func (obj *StorageBin) GetClassName() string {
	return "StorageBin"
}

func (obj *StorageBin) GetTableName() string {
	return "oper_storage_bin"
}

func (obj *StorageBin) GetColumns() []string {
	columns := []string{
		"oper_storage_bin.id",
		"oper_storage_bin.type_id",
		"oper_storage_bin.code",
		"oper_storage_bin.state",
		"oper_storage_bin.warehouse_id",
		"oper_storage_bin.region_id",
		"oper_storage_bin.area_id",
		"oper_storage_bin.aisle",
		"oper_storage_bin.rack_row",
		"oper_storage_bin.rack_col",
		"oper_storage_bin.capacity_preempted",
		"oper_storage_bin.capacity_occupied",
		"oper_storage_bin.capacity_lock",
		"oper_storage_bin.create_at",
		"oper_storage_bin.update_at",
		"oper_storage_bin.create_by",
		"oper_storage_bin.update_by",
	}
	return columns
}

func (obj *StorageBin) GetNoneIncrementColumns() []string {
	columns := []string{
		"type_id",
		"code",
		"state",
		"warehouse_id",
		"region_id",
		"area_id",
		"aisle",
		"rack_row",
		"rack_col",
		"capacity_preempted",
		"capacity_occupied",
		"capacity_lock",
		"create_at",
		"update_at",
		"create_by",
		"update_by",
	}
	return columns
}

func (obj *StorageBin) GetPrimaryKey() PrimaryKey {
	pk := StorageBinMgr.NewPrimaryKey()
	pk.Id = obj.Id
	return pk
}

func (obj *StorageBin) Validate() error {
	validate := validator.New()
	return validate.Struct(obj)
}

type IdOfStorageBinPK struct {
	Id int64
}

func (m *_StorageBinMgr) NewPrimaryKey() *IdOfStorageBinPK {
	return &IdOfStorageBinPK{}
}

func (u *IdOfStorageBinPK) Key() string {
	strs := []string{
		"Id",
		fmt.Sprint(u.Id),
	}
	return strings.Join(strs, ":")
}

func (u *IdOfStorageBinPK) Parse(key string) error {
	arr := strings.Split(key, ":")
	if len(arr)%2 != 0 {
		return fmt.Errorf("key (%s) format error", key)
	}
	kv := map[string]string{}
	for i := 0; i < len(arr)/2; i++ {
		kv[arr[2*i]] = arr[2*i+1]
	}
	vId, ok := kv["Id"]
	if !ok {
		return fmt.Errorf("key (%s) without (Id) field", key)
	}
	if err := orm.StringScan(vId, &(u.Id)); err != nil {
		return err
	}
	return nil
}

func (u *IdOfStorageBinPK) SQLFormat() string {
	conditions := []string{
		"id = ?",
	}
	return orm.SQLWhere(conditions)
}

func (u *IdOfStorageBinPK) SQLParams() []interface{} {
	return []interface{}{
		u.Id,
	}
}

func (u *IdOfStorageBinPK) Columns() []string {
	return []string{
		"id",
	}
}

type UpdateAtOfStorageBinIDX struct {
	UpdateAt int64
	offset   int
	limit    int
}

func (u *UpdateAtOfStorageBinIDX) Key() string {
	strs := []string{
		"UpdateAt",
		fmt.Sprint(u.UpdateAt),
	}
	return strings.Join(strs, ":")
}

func (u *UpdateAtOfStorageBinIDX) SQLFormat(limit bool) string {
	conditions := []string{
		"update_at = ?",
	}
	if limit {
		return fmt.Sprintf("%s %s", orm.SQLWhere(conditions), orm.SQLOffsetLimit(u.offset, u.limit))
	}
	return orm.SQLWhere(conditions)
}

func (u *UpdateAtOfStorageBinIDX) SQLParams() []interface{} {
	return []interface{}{
		u.UpdateAt,
	}
}

func (u *UpdateAtOfStorageBinIDX) SQLLimit() int {
	if u.limit > 0 {
		return u.limit
	}
	return -1
}

func (u *UpdateAtOfStorageBinIDX) Limit(n int) {
	u.limit = n
}

func (u *UpdateAtOfStorageBinIDX) Offset(n int) {
	u.offset = n
}

func (u *UpdateAtOfStorageBinIDX) PositionOffsetLimit(len int) (int, int) {
	if u.limit <= 0 {
		return 0, len
	}
	if u.offset+u.limit > len {
		return u.offset, len
	}
	return u.offset, u.limit
}

type TypeIdOfStorageBinIDX struct {
	TypeId int64
	offset int
	limit  int
}

func (u *TypeIdOfStorageBinIDX) Key() string {
	strs := []string{
		"TypeId",
		fmt.Sprint(u.TypeId),
	}
	return strings.Join(strs, ":")
}

func (u *TypeIdOfStorageBinIDX) SQLFormat(limit bool) string {
	conditions := []string{
		"type_id = ?",
	}
	if limit {
		return fmt.Sprintf("%s %s", orm.SQLWhere(conditions), orm.SQLOffsetLimit(u.offset, u.limit))
	}
	return orm.SQLWhere(conditions)
}

func (u *TypeIdOfStorageBinIDX) SQLParams() []interface{} {
	return []interface{}{
		u.TypeId,
	}
}

func (u *TypeIdOfStorageBinIDX) SQLLimit() int {
	if u.limit > 0 {
		return u.limit
	}
	return -1
}

func (u *TypeIdOfStorageBinIDX) Limit(n int) {
	u.limit = n
}

func (u *TypeIdOfStorageBinIDX) Offset(n int) {
	u.offset = n
}

func (u *TypeIdOfStorageBinIDX) PositionOffsetLimit(len int) (int, int) {
	if u.limit <= 0 {
		return 0, len
	}
	if u.offset+u.limit > len {
		return u.offset, len
	}
	return u.offset, u.limit
}

type RackRowOfStorageBinIDX struct {
	RackRow int32
	offset  int
	limit   int
}

func (u *RackRowOfStorageBinIDX) Key() string {
	strs := []string{
		"RackRow",
		fmt.Sprint(u.RackRow),
	}
	return strings.Join(strs, ":")
}

func (u *RackRowOfStorageBinIDX) SQLFormat(limit bool) string {
	conditions := []string{
		"rack_row = ?",
	}
	if limit {
		return fmt.Sprintf("%s %s", orm.SQLWhere(conditions), orm.SQLOffsetLimit(u.offset, u.limit))
	}
	return orm.SQLWhere(conditions)
}

func (u *RackRowOfStorageBinIDX) SQLParams() []interface{} {
	return []interface{}{
		u.RackRow,
	}
}

func (u *RackRowOfStorageBinIDX) SQLLimit() int {
	if u.limit > 0 {
		return u.limit
	}
	return -1
}

func (u *RackRowOfStorageBinIDX) Limit(n int) {
	u.limit = n
}

func (u *RackRowOfStorageBinIDX) Offset(n int) {
	u.offset = n
}

func (u *RackRowOfStorageBinIDX) PositionOffsetLimit(len int) (int, int) {
	if u.limit <= 0 {
		return 0, len
	}
	if u.offset+u.limit > len {
		return u.offset, len
	}
	return u.offset, u.limit
}

type RackColOfStorageBinIDX struct {
	RackCol int32
	offset  int
	limit   int
}

func (u *RackColOfStorageBinIDX) Key() string {
	strs := []string{
		"RackCol",
		fmt.Sprint(u.RackCol),
	}
	return strings.Join(strs, ":")
}

func (u *RackColOfStorageBinIDX) SQLFormat(limit bool) string {
	conditions := []string{
		"rack_col = ?",
	}
	if limit {
		return fmt.Sprintf("%s %s", orm.SQLWhere(conditions), orm.SQLOffsetLimit(u.offset, u.limit))
	}
	return orm.SQLWhere(conditions)
}

func (u *RackColOfStorageBinIDX) SQLParams() []interface{} {
	return []interface{}{
		u.RackCol,
	}
}

func (u *RackColOfStorageBinIDX) SQLLimit() int {
	if u.limit > 0 {
		return u.limit
	}
	return -1
}

func (u *RackColOfStorageBinIDX) Limit(n int) {
	u.limit = n
}

func (u *RackColOfStorageBinIDX) Offset(n int) {
	u.offset = n
}

func (u *RackColOfStorageBinIDX) PositionOffsetLimit(len int) (int, int) {
	if u.limit <= 0 {
		return 0, len
	}
	if u.offset+u.limit > len {
		return u.offset, len
	}
	return u.offset, u.limit
}

type CodeOfStorageBinIDX struct {
	Code   string
	offset int
	limit  int
}

func (u *CodeOfStorageBinIDX) Key() string {
	strs := []string{
		"Code",
		fmt.Sprint(u.Code),
	}
	return strings.Join(strs, ":")
}

func (u *CodeOfStorageBinIDX) SQLFormat(limit bool) string {
	conditions := []string{
		"code = ?",
	}
	if limit {
		return fmt.Sprintf("%s %s", orm.SQLWhere(conditions), orm.SQLOffsetLimit(u.offset, u.limit))
	}
	return orm.SQLWhere(conditions)
}

func (u *CodeOfStorageBinIDX) SQLParams() []interface{} {
	return []interface{}{
		u.Code,
	}
}

func (u *CodeOfStorageBinIDX) SQLLimit() int {
	if u.limit > 0 {
		return u.limit
	}
	return -1
}

func (u *CodeOfStorageBinIDX) Limit(n int) {
	u.limit = n
}

func (u *CodeOfStorageBinIDX) Offset(n int) {
	u.offset = n
}

func (u *CodeOfStorageBinIDX) PositionOffsetLimit(len int) (int, int) {
	if u.limit <= 0 {
		return 0, len
	}
	if u.offset+u.limit > len {
		return u.offset, len
	}
	return u.offset, u.limit
}

type AisleOfStorageBinIDX struct {
	Aisle  int32
	offset int
	limit  int
}

func (u *AisleOfStorageBinIDX) Key() string {
	strs := []string{
		"Aisle",
		fmt.Sprint(u.Aisle),
	}
	return strings.Join(strs, ":")
}

func (u *AisleOfStorageBinIDX) SQLFormat(limit bool) string {
	conditions := []string{
		"aisle = ?",
	}
	if limit {
		return fmt.Sprintf("%s %s", orm.SQLWhere(conditions), orm.SQLOffsetLimit(u.offset, u.limit))
	}
	return orm.SQLWhere(conditions)
}

func (u *AisleOfStorageBinIDX) SQLParams() []interface{} {
	return []interface{}{
		u.Aisle,
	}
}

func (u *AisleOfStorageBinIDX) SQLLimit() int {
	if u.limit > 0 {
		return u.limit
	}
	return -1
}

func (u *AisleOfStorageBinIDX) Limit(n int) {
	u.limit = n
}

func (u *AisleOfStorageBinIDX) Offset(n int) {
	u.offset = n
}

func (u *AisleOfStorageBinIDX) PositionOffsetLimit(len int) (int, int) {
	if u.limit <= 0 {
		return 0, len
	}
	if u.offset+u.limit > len {
		return u.offset, len
	}
	return u.offset, u.limit
}

type _StorageBinDBMgr struct {
	db orm.DB
}

func (m *_StorageBinMgr) DB(db orm.DB) *_StorageBinDBMgr {
	return StorageBinDBMgr(db)
}

func StorageBinDBMgr(db orm.DB) *_StorageBinDBMgr {
	if db == nil {
		panic(fmt.Errorf("StorageBinDBMgr init need db"))
	}
	return &_StorageBinDBMgr{db: db}
}

func (m *_StorageBinDBMgr) Search(ctx context.Context, where string, orderby string, limit string, args ...interface{}) ([]*StorageBin, error) {
	obj := StorageBinMgr.NewStorageBin()

	if limit = strings.ToUpper(strings.TrimSpace(limit)); limit != "" && !strings.HasPrefix(limit, "LIMIT") {
		limit = "LIMIT " + limit
	}

	conditions := []string{where, orderby, limit}
	query := fmt.Sprintf("SELECT %s FROM oper_storage_bin %s", strings.Join(obj.GetColumns(), ","), strings.Join(conditions, " "))
	return m.FetchBySQL(ctx, query, args...)
}

func (m *_StorageBinDBMgr) SearchConditions(ctx context.Context, conditions []string, orderby string, offset int, limit int, args ...interface{}) ([]*StorageBin, error) {
	obj := StorageBinMgr.NewStorageBin()
	q := fmt.Sprintf("SELECT %s FROM oper_storage_bin %s %s %s",
		strings.Join(obj.GetColumns(), ","),
		orm.SQLWhere(conditions),
		orderby,
		orm.SQLOffsetLimit(offset, limit))

	return m.FetchBySQL(ctx, q, args...)
}

func (m *_StorageBinDBMgr) SearchCount(ctx context.Context, where string, args ...interface{}) (int64, error) {
	return m.queryCount(ctx, where, args...)
}

func (m *_StorageBinDBMgr) SearchConditionsCount(ctx context.Context, conditions []string, args ...interface{}) (int64, error) {
	return m.queryCount(ctx, orm.SQLWhere(conditions), args...)
}

func (m *_StorageBinDBMgr) FetchBySQL(ctx context.Context, q string, args ...interface{}) (results []*StorageBin, err error) {
	rows, err := m.db.Query(ctx, q, args...)
	if err != nil {
		return nil, fmt.Errorf("StorageBin fetch error: %v", err)
	}
	defer rows.Close()

	for rows.Next() {
		var result StorageBin
		err = rows.Scan(&(result.Id), &(result.TypeId), &(result.Code), &(result.State), &(result.WarehouseId), &(result.RegionId), &(result.AreaId), &(result.Aisle), &(result.RackRow), &(result.RackCol), &(result.CapacityPreempted), &(result.CapacityOccupied), &(result.CapacityLock), &(result.CreateAt), &(result.UpdateAt), &(result.CreateBy), &(result.UpdateBy))
		if err != nil {
			m.db.SetError(err)
			return nil, err
		}

		results = append(results, &result)
	}
	if err = rows.Err(); err != nil {
		m.db.SetError(err)
		return nil, fmt.Errorf("StorageBin fetch result error: %v", err)
	}
	return
}
func (m *_StorageBinDBMgr) Exist(ctx context.Context, pk PrimaryKey) (bool, error) {
	c, err := m.queryCount(ctx, pk.SQLFormat(), pk.SQLParams()...)
	if err != nil {
		return false, err
	}
	return (c != 0), nil
}

// FetchByPrimaryKey fetches a single StorageBin by its primary key
// it returns the specific error type(sql.ErrNoRows) when no rows found
func (m *_StorageBinDBMgr) FetchByPrimaryKey(ctx context.Context, _id int64) (*StorageBin, error) {
	obj := StorageBinMgr.NewStorageBin()
	pk := &IdOfStorageBinPK{
		Id: _id,
	}

	query := fmt.Sprintf("SELECT %s FROM oper_storage_bin %s", strings.Join(obj.GetColumns(), ","), pk.SQLFormat())
	objs, err := m.FetchBySQL(ctx, query, pk.SQLParams()...)
	if err != nil {
		return nil, err
	}
	if len(objs) > 0 {
		return objs[0], nil
	}
	return nil, sql.ErrNoRows
}

// err not found check
func (m *_StorageBinDBMgr) IsErrNotFound(err error) bool {
	return strings.Contains(err.Error(), "not found") || errors.Is(err, sql.ErrNoRows)
}

// FetchByPrimaryKeys fetches a list of StorageBin by its primary keys
// it returns the specific error type(sql.ErrNoRows) when no rows found
func (m *_StorageBinDBMgr) FetchByPrimaryKeys(ctx context.Context, _ids []int64) ([]*StorageBin, error) {
	size := len(_ids)
	if size == 0 {
		return nil, nil
	}
	params := make([]interface{}, 0, size)
	for _, pk := range _ids {
		params = append(params, pk)
	}
	obj := StorageBinMgr.NewStorageBin()
	query := fmt.Sprintf("SELECT %s FROM oper_storage_bin WHERE id IN (?%s)", strings.Join(obj.GetColumns(), ","),
		strings.Repeat(",?", size-1))
	objs, err := m.FetchBySQL(ctx, query, params...)
	if err != nil {
		return nil, err
	}
	if len(objs) == 0 {
		return nil, sql.ErrNoRows
	}
	return objs, nil
}

// indexes

func (m *_StorageBinDBMgr) FindByUpdateAt(ctx context.Context, _updateAt int64, limit int, offset int) ([]*StorageBin, error) {
	obj := StorageBinMgr.NewStorageBin()
	idx_ := &UpdateAtOfStorageBinIDX{
		UpdateAt: _updateAt,
		limit:    limit,
		offset:   offset,
	}
	query := fmt.Sprintf("SELECT %s FROM oper_storage_bin %s", strings.Join(obj.GetColumns(), ","), idx_.SQLFormat(true))
	return m.FetchBySQL(ctx, query, idx_.SQLParams()...)
}

func (m *_StorageBinDBMgr) FindAllByUpdateAt(ctx context.Context, _updateAt int64) ([]*StorageBin, error) {
	obj := StorageBinMgr.NewStorageBin()
	idx_ := &UpdateAtOfStorageBinIDX{
		UpdateAt: _updateAt,
	}

	query := fmt.Sprintf("SELECT %s FROM oper_storage_bin %s", strings.Join(obj.GetColumns(), ","), idx_.SQLFormat(true))
	return m.FetchBySQL(ctx, query, idx_.SQLParams()...)
}

func (m *_StorageBinDBMgr) FindByUpdateAtGroup(ctx context.Context, items []int64) ([]*StorageBin, error) {
	obj := StorageBinMgr.NewStorageBin()
	if len(items) == 0 {
		return nil, nil
	}
	params := make([]interface{}, 0, len(items))
	for _, item := range items {
		params = append(params, item)
	}
	query := fmt.Sprintf("SELECT %s FROM oper_storage_bin where update_at in (?", strings.Join(obj.GetColumns(), ",")) +
		strings.Repeat(",?", len(items)-1) + ")"
	return m.FetchBySQL(ctx, query, params...)
}

func (m *_StorageBinDBMgr) FindByTypeId(ctx context.Context, _typeId int64, limit int, offset int) ([]*StorageBin, error) {
	obj := StorageBinMgr.NewStorageBin()
	idx_ := &TypeIdOfStorageBinIDX{
		TypeId: _typeId,
		limit:  limit,
		offset: offset,
	}
	query := fmt.Sprintf("SELECT %s FROM oper_storage_bin %s", strings.Join(obj.GetColumns(), ","), idx_.SQLFormat(true))
	return m.FetchBySQL(ctx, query, idx_.SQLParams()...)
}

func (m *_StorageBinDBMgr) FindAllByTypeId(ctx context.Context, _typeId int64) ([]*StorageBin, error) {
	obj := StorageBinMgr.NewStorageBin()
	idx_ := &TypeIdOfStorageBinIDX{
		TypeId: _typeId,
	}

	query := fmt.Sprintf("SELECT %s FROM oper_storage_bin %s", strings.Join(obj.GetColumns(), ","), idx_.SQLFormat(true))
	return m.FetchBySQL(ctx, query, idx_.SQLParams()...)
}

func (m *_StorageBinDBMgr) FindByTypeIdGroup(ctx context.Context, items []int64) ([]*StorageBin, error) {
	obj := StorageBinMgr.NewStorageBin()
	if len(items) == 0 {
		return nil, nil
	}
	params := make([]interface{}, 0, len(items))
	for _, item := range items {
		params = append(params, item)
	}
	query := fmt.Sprintf("SELECT %s FROM oper_storage_bin where type_id in (?", strings.Join(obj.GetColumns(), ",")) +
		strings.Repeat(",?", len(items)-1) + ")"
	return m.FetchBySQL(ctx, query, params...)
}

func (m *_StorageBinDBMgr) FindByRackRow(ctx context.Context, _rackRow int32, limit int, offset int) ([]*StorageBin, error) {
	obj := StorageBinMgr.NewStorageBin()
	idx_ := &RackRowOfStorageBinIDX{
		RackRow: _rackRow,
		limit:   limit,
		offset:  offset,
	}
	query := fmt.Sprintf("SELECT %s FROM oper_storage_bin %s", strings.Join(obj.GetColumns(), ","), idx_.SQLFormat(true))
	return m.FetchBySQL(ctx, query, idx_.SQLParams()...)
}

func (m *_StorageBinDBMgr) FindAllByRackRow(ctx context.Context, _rackRow int32) ([]*StorageBin, error) {
	obj := StorageBinMgr.NewStorageBin()
	idx_ := &RackRowOfStorageBinIDX{
		RackRow: _rackRow,
	}

	query := fmt.Sprintf("SELECT %s FROM oper_storage_bin %s", strings.Join(obj.GetColumns(), ","), idx_.SQLFormat(true))
	return m.FetchBySQL(ctx, query, idx_.SQLParams()...)
}

func (m *_StorageBinDBMgr) FindByRackRowGroup(ctx context.Context, items []int32) ([]*StorageBin, error) {
	obj := StorageBinMgr.NewStorageBin()
	if len(items) == 0 {
		return nil, nil
	}
	params := make([]interface{}, 0, len(items))
	for _, item := range items {
		params = append(params, item)
	}
	query := fmt.Sprintf("SELECT %s FROM oper_storage_bin where rack_row in (?", strings.Join(obj.GetColumns(), ",")) +
		strings.Repeat(",?", len(items)-1) + ")"
	return m.FetchBySQL(ctx, query, params...)
}

func (m *_StorageBinDBMgr) FindByRackCol(ctx context.Context, _rackCol int32, limit int, offset int) ([]*StorageBin, error) {
	obj := StorageBinMgr.NewStorageBin()
	idx_ := &RackColOfStorageBinIDX{
		RackCol: _rackCol,
		limit:   limit,
		offset:  offset,
	}
	query := fmt.Sprintf("SELECT %s FROM oper_storage_bin %s", strings.Join(obj.GetColumns(), ","), idx_.SQLFormat(true))
	return m.FetchBySQL(ctx, query, idx_.SQLParams()...)
}

func (m *_StorageBinDBMgr) FindAllByRackCol(ctx context.Context, _rackCol int32) ([]*StorageBin, error) {
	obj := StorageBinMgr.NewStorageBin()
	idx_ := &RackColOfStorageBinIDX{
		RackCol: _rackCol,
	}

	query := fmt.Sprintf("SELECT %s FROM oper_storage_bin %s", strings.Join(obj.GetColumns(), ","), idx_.SQLFormat(true))
	return m.FetchBySQL(ctx, query, idx_.SQLParams()...)
}

func (m *_StorageBinDBMgr) FindByRackColGroup(ctx context.Context, items []int32) ([]*StorageBin, error) {
	obj := StorageBinMgr.NewStorageBin()
	if len(items) == 0 {
		return nil, nil
	}
	params := make([]interface{}, 0, len(items))
	for _, item := range items {
		params = append(params, item)
	}
	query := fmt.Sprintf("SELECT %s FROM oper_storage_bin where rack_col in (?", strings.Join(obj.GetColumns(), ",")) +
		strings.Repeat(",?", len(items)-1) + ")"
	return m.FetchBySQL(ctx, query, params...)
}

func (m *_StorageBinDBMgr) FindByCode(ctx context.Context, _code string, limit int, offset int) ([]*StorageBin, error) {
	obj := StorageBinMgr.NewStorageBin()
	idx_ := &CodeOfStorageBinIDX{
		Code:   _code,
		limit:  limit,
		offset: offset,
	}
	query := fmt.Sprintf("SELECT %s FROM oper_storage_bin %s", strings.Join(obj.GetColumns(), ","), idx_.SQLFormat(true))
	return m.FetchBySQL(ctx, query, idx_.SQLParams()...)
}

func (m *_StorageBinDBMgr) FindAllByCode(ctx context.Context, _code string) ([]*StorageBin, error) {
	obj := StorageBinMgr.NewStorageBin()
	idx_ := &CodeOfStorageBinIDX{
		Code: _code,
	}

	query := fmt.Sprintf("SELECT %s FROM oper_storage_bin %s", strings.Join(obj.GetColumns(), ","), idx_.SQLFormat(true))
	return m.FetchBySQL(ctx, query, idx_.SQLParams()...)
}

func (m *_StorageBinDBMgr) FindByCodeGroup(ctx context.Context, items []string) ([]*StorageBin, error) {
	obj := StorageBinMgr.NewStorageBin()
	if len(items) == 0 {
		return nil, nil
	}
	params := make([]interface{}, 0, len(items))
	for _, item := range items {
		params = append(params, item)
	}
	query := fmt.Sprintf("SELECT %s FROM oper_storage_bin where code in (?", strings.Join(obj.GetColumns(), ",")) +
		strings.Repeat(",?", len(items)-1) + ")"
	return m.FetchBySQL(ctx, query, params...)
}

func (m *_StorageBinDBMgr) FindByAisle(ctx context.Context, _aisle int32, limit int, offset int) ([]*StorageBin, error) {
	obj := StorageBinMgr.NewStorageBin()
	idx_ := &AisleOfStorageBinIDX{
		Aisle:  _aisle,
		limit:  limit,
		offset: offset,
	}
	query := fmt.Sprintf("SELECT %s FROM oper_storage_bin %s", strings.Join(obj.GetColumns(), ","), idx_.SQLFormat(true))
	return m.FetchBySQL(ctx, query, idx_.SQLParams()...)
}

func (m *_StorageBinDBMgr) FindAllByAisle(ctx context.Context, _aisle int32) ([]*StorageBin, error) {
	obj := StorageBinMgr.NewStorageBin()
	idx_ := &AisleOfStorageBinIDX{
		Aisle: _aisle,
	}

	query := fmt.Sprintf("SELECT %s FROM oper_storage_bin %s", strings.Join(obj.GetColumns(), ","), idx_.SQLFormat(true))
	return m.FetchBySQL(ctx, query, idx_.SQLParams()...)
}

func (m *_StorageBinDBMgr) FindByAisleGroup(ctx context.Context, items []int32) ([]*StorageBin, error) {
	obj := StorageBinMgr.NewStorageBin()
	if len(items) == 0 {
		return nil, nil
	}
	params := make([]interface{}, 0, len(items))
	for _, item := range items {
		params = append(params, item)
	}
	query := fmt.Sprintf("SELECT %s FROM oper_storage_bin where aisle in (?", strings.Join(obj.GetColumns(), ",")) +
		strings.Repeat(",?", len(items)-1) + ")"
	return m.FetchBySQL(ctx, query, params...)
}

// uniques

func (m *_StorageBinDBMgr) FindOne(ctx context.Context, unique Unique) (PrimaryKey, error) {
	objs, err := m.queryLimit(ctx, unique.SQLFormat(true), unique.SQLLimit(), unique.SQLParams()...)
	if err != nil {
		return nil, err
	}
	if len(objs) > 0 {
		return objs[0], nil
	}
	return nil, fmt.Errorf("StorageBin find record not found")
}

func (m *_StorageBinDBMgr) FindFetch(ctx context.Context, index Index) (int64, []*StorageBin, error) {
	total, err := m.queryCount(ctx, index.SQLFormat(false), index.SQLParams()...)
	if err != nil {
		return total, nil, err
	}

	obj := StorageBinMgr.NewStorageBin()
	query := fmt.Sprintf("SELECT %s FROM oper_storage_bin %s", strings.Join(obj.GetColumns(), ","), index.SQLFormat(true))
	results, err := m.FetchBySQL(ctx, query, index.SQLParams()...)
	if err != nil {
		return total, nil, err
	}
	return total, results, nil
}

func (m *_StorageBinDBMgr) queryLimit(ctx context.Context, where string, limit int, args ...interface{}) (results []PrimaryKey, err error) {
	pk := StorageBinMgr.NewPrimaryKey()
	query := fmt.Sprintf("SELECT %s FROM oper_storage_bin %s", strings.Join(pk.Columns(), ","), where)
	rows, err := m.db.Query(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("StorageBin query limit error: %v", err)
	}
	defer rows.Close()

	offset := 0

	for rows.Next() {
		if limit >= 0 && offset >= limit {
			break
		}
		offset++

		result := StorageBinMgr.NewPrimaryKey()
		err = rows.Scan(&(result.Id))
		if err != nil {
			m.db.SetError(err)
			return nil, err
		}

		results = append(results, result)
	}
	if err := rows.Err(); err != nil {
		m.db.SetError(err)
		return nil, fmt.Errorf("StorageBin query limit result error: %v", err)
	}
	return
}

func (m *_StorageBinDBMgr) queryCount(ctx context.Context, where string, args ...interface{}) (int64, error) {
	query := fmt.Sprintf("SELECT count( id ) FROM oper_storage_bin %s", where)
	rows, err := m.db.Query(ctx, query, args...)
	if err != nil {
		return 0, fmt.Errorf("StorageBin query count error: %v", err)
	}
	defer rows.Close()

	var count int64
	if rows.Next() {
		if err = rows.Scan(&count); err != nil {
			m.db.SetError(err)
			return 0, err
		}
	}
	return count, nil
}

func (m *_StorageBinDBMgr) BatchCreate(ctx context.Context, objs []*StorageBin) (int64, error) {
	if len(objs) == 0 {
		return 0, nil
	}

	params := make([]string, 0, len(objs))
	values := make([]interface{}, 0, len(objs)*16)
	for _, obj := range objs {
		params = append(params, fmt.Sprintf("(%s)", strings.Join(orm.NewStringSlice(16, "?"), ",")))
		values = append(values, obj.TypeId)
		values = append(values, obj.Code)
		values = append(values, obj.State)
		values = append(values, obj.WarehouseId)
		values = append(values, obj.RegionId)
		values = append(values, obj.AreaId)
		values = append(values, obj.Aisle)
		values = append(values, obj.RackRow)
		values = append(values, obj.RackCol)
		values = append(values, obj.CapacityPreempted)
		values = append(values, obj.CapacityOccupied)
		values = append(values, obj.CapacityLock)
		values = append(values, obj.CreateAt)
		values = append(values, obj.UpdateAt)
		values = append(values, obj.CreateBy)
		values = append(values, obj.UpdateBy)
	}
	query := fmt.Sprintf("INSERT INTO oper_storage_bin(%s) VALUES %s", strings.Join(objs[0].GetNoneIncrementColumns(), ","), strings.Join(params, ","))
	result, err := m.db.Exec(ctx, query, values...)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

// argument example:
// set:"a=?, b=?"
// where:"c=? and d=?"
// params:[]interface{}{"a", "b", "c", "d"}...
func (m *_StorageBinDBMgr) UpdateBySQL(ctx context.Context, set, where string, args ...interface{}) (int64, error) {
	query := fmt.Sprintf("UPDATE oper_storage_bin SET %s", set)
	if where != "" {
		query = fmt.Sprintf("UPDATE oper_storage_bin SET %s WHERE %s", set, where)
	}
	result, err := m.db.Exec(ctx, query, args...)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

func (m *_StorageBinDBMgr) Create(ctx context.Context, obj *StorageBin) (int64, error) {
	params := orm.NewStringSlice(16, "?")
	q := fmt.Sprintf("INSERT INTO oper_storage_bin(%s) VALUES(%s)",
		strings.Join(obj.GetNoneIncrementColumns(), ","),
		strings.Join(params, ","))

	values := make([]interface{}, 0, 17)
	values = append(values, obj.TypeId)
	values = append(values, obj.Code)
	values = append(values, obj.State)
	values = append(values, obj.WarehouseId)
	values = append(values, obj.RegionId)
	values = append(values, obj.AreaId)
	values = append(values, obj.Aisle)
	values = append(values, obj.RackRow)
	values = append(values, obj.RackCol)
	values = append(values, obj.CapacityPreempted)
	values = append(values, obj.CapacityOccupied)
	values = append(values, obj.CapacityLock)
	values = append(values, obj.CreateAt)
	values = append(values, obj.UpdateAt)
	values = append(values, obj.CreateBy)
	values = append(values, obj.UpdateBy)
	result, err := m.db.Exec(ctx, q, values...)
	if err != nil {
		return 0, err
	}
	lastInsertId, err := result.LastInsertId()
	if err != nil {
		return 0, err
	}
	obj.Id = int64(lastInsertId)
	return result.RowsAffected()
}

func (m *_StorageBinDBMgr) Update(ctx context.Context, obj *StorageBin) (int64, error) {
	columns := []string{
		"type_id = ?",
		"code = ?",
		"state = ?",
		"warehouse_id = ?",
		"region_id = ?",
		"area_id = ?",
		"aisle = ?",
		"rack_row = ?",
		"rack_col = ?",
		"capacity_preempted = ?",
		"capacity_occupied = ?",
		"capacity_lock = ?",
		"create_at = ?",
		"update_at = ?",
		"create_by = ?",
		"update_by = ?",
	}

	pk := obj.GetPrimaryKey()
	q := fmt.Sprintf("UPDATE oper_storage_bin SET %s %s", strings.Join(columns, ","), pk.SQLFormat())
	values := make([]interface{}, 0, 17-1)
	values = append(values, obj.TypeId)
	values = append(values, obj.Code)
	values = append(values, obj.State)
	values = append(values, obj.WarehouseId)
	values = append(values, obj.RegionId)
	values = append(values, obj.AreaId)
	values = append(values, obj.Aisle)
	values = append(values, obj.RackRow)
	values = append(values, obj.RackCol)
	values = append(values, obj.CapacityPreempted)
	values = append(values, obj.CapacityOccupied)
	values = append(values, obj.CapacityLock)
	values = append(values, obj.CreateAt)
	values = append(values, obj.UpdateAt)
	values = append(values, obj.CreateBy)
	values = append(values, obj.UpdateBy)
	values = append(values, pk.SQLParams()...)

	result, err := m.db.Exec(ctx, q, values...)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

func (m *_StorageBinDBMgr) Save(ctx context.Context, obj *StorageBin) (int64, error) {
	affected, err := m.Update(ctx, obj)
	if err != nil {
		return affected, err
	}
	if affected == 0 {
		return m.Create(ctx, obj)
	}
	return affected, err
}

func (m *_StorageBinDBMgr) Delete(ctx context.Context, obj *StorageBin) (int64, error) {
	return m.DeleteByPrimaryKey(ctx, obj.Id)
}

func (m *_StorageBinDBMgr) DeleteByPrimaryKey(ctx context.Context, _id int64) (int64, error) {
	pk := &IdOfStorageBinPK{
		Id: _id,
	}
	q := fmt.Sprintf("DELETE FROM oper_storage_bin %s", pk.SQLFormat())
	result, err := m.db.Exec(ctx, q, pk.SQLParams()...)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

func (m *_StorageBinDBMgr) DeleteBySQL(ctx context.Context, where string, args ...interface{}) (int64, error) {
	query := "DELETE FROM oper_storage_bin"
	if where != "" {
		query = fmt.Sprintf("DELETE FROM oper_storage_bin WHERE %s", where)
	}
	result, err := m.db.Exec(ctx, query, args...)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
