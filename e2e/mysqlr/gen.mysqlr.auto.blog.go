// Package mysqlr is generated by ezorm (v2)
// DO NOT EDIT
package mysqlr

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/ezbuy/ezorm/v2/pkg/orm"

	validator "gopkg.in/go-playground/validator.v9"
)

var (
	_ sql.DB
	_ time.Time
	_ fmt.Formatter
	_ strings.Reader
	_ validator.Validate
	_ context.Context
)

type AutoBlog struct {
	Id        int64     `mysql:"id"`
	UserId    int32     `mysql:"user_id"`
	Title     string    `mysql:"title"`
	Content   string    `mysql:"content"`
	Status    int32     `mysql:"status"`
	Readed    int32     `mysql:"readed"`
	CreatedAt time.Time `mysql:"created_at"`
	UpdatedAt time.Time `mysql:"updated_at"`
}

var AutoBlogColumns = struct {
	Id        string
	UserId    string
	Title     string
	Content   string
	Status    string
	Readed    string
	CreatedAt string
	UpdatedAt string
}{
	"id",
	"user_id",
	"title",
	"content",
	"status",
	"readed",
	"created_at",
	"updated_at",
}

type _AutoBlogMgr struct {
}

var AutoBlogMgr *_AutoBlogMgr

func (m *_AutoBlogMgr) NewAutoBlog() *AutoBlog {
	return &AutoBlog{}
}

func (obj *AutoBlog) GetNameSpace() string {
	return "mysqlr_e2e"
}

func (obj *AutoBlog) GetClassName() string {
	return "AutoBlog"
}

func (obj *AutoBlog) GetTableName() string {
	return "auto_blogs"
}

func (obj *AutoBlog) GetColumns() []string {
	columns := []string{
		"auto_blogs.id",
		"auto_blogs.user_id",
		"auto_blogs.title",
		"auto_blogs.content",
		"auto_blogs.status",
		"auto_blogs.readed",
		"auto_blogs.created_at",
		"auto_blogs.updated_at",
	}
	return columns
}

func (obj *AutoBlog) GetNoneIncrementColumns() []string {
	columns := []string{
		"user_id",
		"title",
		"content",
		"status",
		"readed",
		"created_at",
		"updated_at",
	}
	return columns
}

func (obj *AutoBlog) GetPrimaryKey() PrimaryKey {
	pk := AutoBlogMgr.NewPrimaryKey()
	pk.Id = obj.Id
	return pk
}

func (obj *AutoBlog) Validate() error {
	validate := validator.New()
	return validate.Struct(obj)
}

type IdOfAutoBlogPK struct {
	Id int64
}

func (m *_AutoBlogMgr) NewPrimaryKey() *IdOfAutoBlogPK {
	return &IdOfAutoBlogPK{}
}

func (u *IdOfAutoBlogPK) Key() string {
	strs := []string{
		"Id",
		fmt.Sprint(u.Id),
	}
	return strings.Join(strs, ":")
}

func (u *IdOfAutoBlogPK) Parse(key string) error {
	arr := strings.Split(key, ":")
	if len(arr)%2 != 0 {
		return fmt.Errorf("key (%s) format error", key)
	}
	kv := map[string]string{}
	for i := 0; i < len(arr)/2; i++ {
		kv[arr[2*i]] = arr[2*i+1]
	}
	vId, ok := kv["Id"]
	if !ok {
		return fmt.Errorf("key (%s) without (Id) field", key)
	}
	if err := orm.StringScan(vId, &(u.Id)); err != nil {
		return err
	}
	return nil
}

func (u *IdOfAutoBlogPK) SQLFormat() string {
	conditions := []string{
		"id = ?",
	}
	return orm.SQLWhere(conditions)
}

func (u *IdOfAutoBlogPK) SQLParams() []interface{} {
	return []interface{}{
		u.Id,
	}
}

func (u *IdOfAutoBlogPK) Columns() []string {
	return []string{
		"id",
	}
}

type StatusOfAutoBlogIDX struct {
	Status int32
	offset int
	limit  int
}

func (u *StatusOfAutoBlogIDX) Key() string {
	strs := []string{
		"Status",
		fmt.Sprint(u.Status),
	}
	return strings.Join(strs, ":")
}

func (u *StatusOfAutoBlogIDX) SQLFormat(limit bool) string {
	conditions := []string{
		"status = ?",
	}
	if limit {
		return fmt.Sprintf("%s %s", orm.SQLWhere(conditions), orm.SQLOffsetLimit(u.offset, u.limit))
	}
	return orm.SQLWhere(conditions)
}

func (u *StatusOfAutoBlogIDX) SQLParams() []interface{} {
	return []interface{}{
		u.Status,
	}
}

func (u *StatusOfAutoBlogIDX) SQLLimit() int {
	if u.limit > 0 {
		return u.limit
	}
	return -1
}

func (u *StatusOfAutoBlogIDX) Limit(n int) {
	u.limit = n
}

func (u *StatusOfAutoBlogIDX) Offset(n int) {
	u.offset = n
}

func (u *StatusOfAutoBlogIDX) PositionOffsetLimit(len int) (int, int) {
	if u.limit <= 0 {
		return 0, len
	}
	if u.offset+u.limit > len {
		return u.offset, len
	}
	return u.offset, u.limit
}

type _AutoBlogDBMgr struct {
	db orm.DB
}

func (m *_AutoBlogMgr) DB(db orm.DB) *_AutoBlogDBMgr {
	return AutoBlogDBMgr(db)
}

func AutoBlogDBMgr(db orm.DB) *_AutoBlogDBMgr {
	if db == nil {
		panic(fmt.Errorf("AutoBlogDBMgr init need db"))
	}
	return &_AutoBlogDBMgr{db: db}
}

func (m *_AutoBlogDBMgr) Search(ctx context.Context, where string, orderby string, limit string, args ...interface{}) ([]*AutoBlog, error) {
	obj := AutoBlogMgr.NewAutoBlog()

	if limit = strings.ToUpper(strings.TrimSpace(limit)); limit != "" && !strings.HasPrefix(limit, "LIMIT") {
		limit = "LIMIT " + limit
	}

	conditions := []string{where, orderby, limit}
	query := fmt.Sprintf("SELECT %s FROM auto_blogs %s", strings.Join(obj.GetColumns(), ","), strings.Join(conditions, " "))
	return m.FetchBySQL(ctx, query, args...)
}

func (m *_AutoBlogDBMgr) SearchConditions(ctx context.Context, conditions []string, orderby string, offset int, limit int, args ...interface{}) ([]*AutoBlog, error) {
	obj := AutoBlogMgr.NewAutoBlog()
	q := fmt.Sprintf("SELECT %s FROM auto_blogs %s %s %s",
		strings.Join(obj.GetColumns(), ","),
		orm.SQLWhere(conditions),
		orderby,
		orm.SQLOffsetLimit(offset, limit))

	return m.FetchBySQL(ctx, q, args...)
}

func (m *_AutoBlogDBMgr) SearchCount(ctx context.Context, where string, args ...interface{}) (int64, error) {
	return m.queryCount(ctx, where, args...)
}

func (m *_AutoBlogDBMgr) SearchConditionsCount(ctx context.Context, conditions []string, args ...interface{}) (int64, error) {
	return m.queryCount(ctx, orm.SQLWhere(conditions), args...)
}

func (m *_AutoBlogDBMgr) FetchBySQL(ctx context.Context, q string, args ...interface{}) (results []*AutoBlog, err error) {
	rows, err := m.db.Query(ctx, q, args...)
	if err != nil {
		return nil, fmt.Errorf("AutoBlog fetch error: %v", err)
	}
	defer rows.Close()

	var CreatedAt string
	var UpdatedAt int64

	for rows.Next() {
		var result AutoBlog
		err = rows.Scan(&(result.Id), &(result.UserId), &(result.Title), &(result.Content), &(result.Status), &(result.Readed), &CreatedAt, &UpdatedAt)
		if err != nil {
			m.db.SetError(err)
			return nil, err
		}

		result.CreatedAt = orm.TimeParse(CreatedAt)
		result.UpdatedAt = time.Unix(UpdatedAt, 0)

		results = append(results, &result)
	}
	if err = rows.Err(); err != nil {
		m.db.SetError(err)
		return nil, fmt.Errorf("AutoBlog fetch result error: %v", err)
	}
	return
}
func (m *_AutoBlogDBMgr) Exist(ctx context.Context, pk PrimaryKey) (bool, error) {
	c, err := m.queryCount(ctx, pk.SQLFormat(), pk.SQLParams()...)
	if err != nil {
		return false, err
	}
	return (c != 0), nil
}

// FetchByPrimaryKey fetches a single AutoBlog by its primary key
// it returns the specific error type(sql.ErrNoRows) when no rows found
func (m *_AutoBlogDBMgr) FetchByPrimaryKey(ctx context.Context, _id int64) (*AutoBlog, error) {
	obj := AutoBlogMgr.NewAutoBlog()
	pk := &IdOfAutoBlogPK{
		Id: _id,
	}

	query := fmt.Sprintf("SELECT %s FROM auto_blogs %s", strings.Join(obj.GetColumns(), ","), pk.SQLFormat())
	objs, err := m.FetchBySQL(ctx, query, pk.SQLParams()...)
	if err != nil {
		return nil, err
	}
	if len(objs) > 0 {
		return objs[0], nil
	}
	return nil, sql.ErrNoRows
}

// err not found check
func (m *_AutoBlogDBMgr) IsErrNotFound(err error) bool {
	return strings.Contains(err.Error(), "not found") || errors.Is(err, sql.ErrNoRows)
}

// FetchByPrimaryKeys fetches a list of AutoBlog by its primary keys
// it returns the specific error type(sql.ErrNoRows) when no rows found
func (m *_AutoBlogDBMgr) FetchByPrimaryKeys(ctx context.Context, _ids []int64) ([]*AutoBlog, error) {
	size := len(_ids)
	if size == 0 {
		return nil, nil
	}
	params := make([]interface{}, 0, size)
	for _, pk := range _ids {
		params = append(params, pk)
	}
	obj := AutoBlogMgr.NewAutoBlog()
	query := fmt.Sprintf("SELECT %s FROM auto_blogs WHERE id IN (?%s)", strings.Join(obj.GetColumns(), ","),
		strings.Repeat(",?", size-1))
	objs, err := m.FetchBySQL(ctx, query, params...)
	if err != nil {
		return nil, err
	}
	if len(objs) == 0 {
		return nil, sql.ErrNoRows
	}
	return objs, nil
}

// indexes

func (m *_AutoBlogDBMgr) FindByStatus(ctx context.Context, _status int32, limit int, offset int) ([]*AutoBlog, error) {
	obj := AutoBlogMgr.NewAutoBlog()
	idx_ := &StatusOfAutoBlogIDX{
		Status: _status,
		limit:  limit,
		offset: offset,
	}
	query := fmt.Sprintf("SELECT %s FROM auto_blogs %s", strings.Join(obj.GetColumns(), ","), idx_.SQLFormat(true))
	return m.FetchBySQL(ctx, query, idx_.SQLParams()...)
}

func (m *_AutoBlogDBMgr) FindAllByStatus(ctx context.Context, _status int32) ([]*AutoBlog, error) {
	obj := AutoBlogMgr.NewAutoBlog()
	idx_ := &StatusOfAutoBlogIDX{
		Status: _status,
	}

	query := fmt.Sprintf("SELECT %s FROM auto_blogs %s", strings.Join(obj.GetColumns(), ","), idx_.SQLFormat(true))
	return m.FetchBySQL(ctx, query, idx_.SQLParams()...)
}

func (m *_AutoBlogDBMgr) FindByStatusGroup(ctx context.Context, items []int32) ([]*AutoBlog, error) {
	obj := AutoBlogMgr.NewAutoBlog()
	if len(items) == 0 {
		return nil, nil
	}
	params := make([]interface{}, 0, len(items))
	for _, item := range items {
		params = append(params, item)
	}
	query := fmt.Sprintf("SELECT %s FROM auto_blogs where status in (?", strings.Join(obj.GetColumns(), ",")) +
		strings.Repeat(",?", len(items)-1) + ")"
	return m.FetchBySQL(ctx, query, params...)
}

// uniques

func (m *_AutoBlogDBMgr) FindOne(ctx context.Context, unique Unique) (PrimaryKey, error) {
	objs, err := m.queryLimit(ctx, unique.SQLFormat(true), unique.SQLLimit(), unique.SQLParams()...)
	if err != nil {
		return nil, err
	}
	if len(objs) > 0 {
		return objs[0], nil
	}
	return nil, fmt.Errorf("AutoBlog find record not found")
}

func (m *_AutoBlogDBMgr) FindFetch(ctx context.Context, index Index) (int64, []*AutoBlog, error) {
	total, err := m.queryCount(ctx, index.SQLFormat(false), index.SQLParams()...)
	if err != nil {
		return total, nil, err
	}

	obj := AutoBlogMgr.NewAutoBlog()
	query := fmt.Sprintf("SELECT %s FROM auto_blogs %s", strings.Join(obj.GetColumns(), ","), index.SQLFormat(true))
	results, err := m.FetchBySQL(ctx, query, index.SQLParams()...)
	if err != nil {
		return total, nil, err
	}
	return total, results, nil
}

func (m *_AutoBlogDBMgr) queryLimit(ctx context.Context, where string, limit int, args ...interface{}) (results []PrimaryKey, err error) {
	pk := AutoBlogMgr.NewPrimaryKey()
	query := fmt.Sprintf("SELECT %s FROM auto_blogs %s", strings.Join(pk.Columns(), ","), where)
	rows, err := m.db.Query(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("AutoBlog query limit error: %v", err)
	}
	defer rows.Close()

	offset := 0

	for rows.Next() {
		if limit >= 0 && offset >= limit {
			break
		}
		offset++

		result := AutoBlogMgr.NewPrimaryKey()
		err = rows.Scan(&(result.Id))
		if err != nil {
			m.db.SetError(err)
			return nil, err
		}

		results = append(results, result)
	}
	if err := rows.Err(); err != nil {
		m.db.SetError(err)
		return nil, fmt.Errorf("AutoBlog query limit result error: %v", err)
	}
	return
}

func (m *_AutoBlogDBMgr) queryCount(ctx context.Context, where string, args ...interface{}) (int64, error) {
	query := fmt.Sprintf("SELECT count( id ) FROM auto_blogs %s", where)
	rows, err := m.db.Query(ctx, query, args...)
	if err != nil {
		return 0, fmt.Errorf("AutoBlog query count error: %v", err)
	}
	defer rows.Close()

	var count int64
	if rows.Next() {
		if err = rows.Scan(&count); err != nil {
			m.db.SetError(err)
			return 0, err
		}
	}
	return count, nil
}

func (m *_AutoBlogDBMgr) BatchCreate(ctx context.Context, objs []*AutoBlog) (int64, error) {
	if len(objs) == 0 {
		return 0, nil
	}

	params := make([]string, 0, len(objs))
	values := make([]interface{}, 0, len(objs)*7)
	for _, obj := range objs {
		params = append(params, fmt.Sprintf("(%s)", strings.Join(orm.NewStringSlice(7, "?"), ",")))
		values = append(values, obj.UserId)
		values = append(values, obj.Title)
		values = append(values, obj.Content)
		values = append(values, obj.Status)
		values = append(values, obj.Readed)
		values = append(values, orm.TimeFormat(obj.CreatedAt))
		values = append(values, obj.UpdatedAt.Unix())
	}
	query := fmt.Sprintf("INSERT INTO auto_blogs(%s) VALUES %s", strings.Join(objs[0].GetNoneIncrementColumns(), ","), strings.Join(params, ","))
	result, err := m.db.Exec(ctx, query, values...)
	if err != nil {
		return 0, err
	}
	lastInsertID, err := result.LastInsertId()
	if err != nil {
		return 0, err
	}
	aff, err := result.RowsAffected()
	if err != nil {
		return 0, err
	}
	for i := 0; i < int(aff); i++ {
		objs[i].Id = int64(lastInsertID + int64(i))
	}

	return result.RowsAffected()
}

// argument example:
// set:"a=?, b=?"
// where:"c=? and d=?"
// params:[]interface{}{"a", "b", "c", "d"}...
func (m *_AutoBlogDBMgr) UpdateBySQL(ctx context.Context, set, where string, args ...interface{}) (int64, error) {
	query := fmt.Sprintf("UPDATE auto_blogs SET %s", set)
	if where != "" {
		query = fmt.Sprintf("UPDATE auto_blogs SET %s WHERE %s", set, where)
	}
	result, err := m.db.Exec(ctx, query, args...)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

func (m *_AutoBlogDBMgr) Create(ctx context.Context, obj *AutoBlog) (int64, error) {
	params := orm.NewStringSlice(7, "?")
	q := fmt.Sprintf("INSERT INTO auto_blogs(%s) VALUES(%s)",
		strings.Join(obj.GetNoneIncrementColumns(), ","),
		strings.Join(params, ","))

	values := make([]interface{}, 0, 8)
	values = append(values, obj.UserId)
	values = append(values, obj.Title)
	values = append(values, obj.Content)
	values = append(values, obj.Status)
	values = append(values, obj.Readed)
	values = append(values, orm.TimeFormat(obj.CreatedAt))
	values = append(values, obj.UpdatedAt.Unix())
	result, err := m.db.Exec(ctx, q, values...)
	if err != nil {
		return 0, err
	}
	lastInsertId, err := result.LastInsertId()
	if err != nil {
		return 0, err
	}
	obj.Id = int64(lastInsertId)
	return result.RowsAffected()
}

func (m *_AutoBlogDBMgr) Update(ctx context.Context, obj *AutoBlog) (int64, error) {
	columns := []string{
		"user_id = ?",
		"title = ?",
		"content = ?",
		"status = ?",
		"readed = ?",
		"created_at = ?",
		"updated_at = ?",
	}

	pk := obj.GetPrimaryKey()
	q := fmt.Sprintf("UPDATE auto_blogs SET %s %s", strings.Join(columns, ","), pk.SQLFormat())
	values := make([]interface{}, 0, 8-1)
	values = append(values, obj.UserId)
	values = append(values, obj.Title)
	values = append(values, obj.Content)
	values = append(values, obj.Status)
	values = append(values, obj.Readed)
	values = append(values, orm.TimeFormat(obj.CreatedAt))
	values = append(values, obj.UpdatedAt.Unix())
	values = append(values, pk.SQLParams()...)

	result, err := m.db.Exec(ctx, q, values...)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

func (m *_AutoBlogDBMgr) Save(ctx context.Context, obj *AutoBlog) (int64, error) {
	affected, err := m.Update(ctx, obj)
	if err != nil {
		return affected, err
	}
	if affected == 0 {
		return m.Create(ctx, obj)
	}
	return affected, err
}

func (m *_AutoBlogDBMgr) Delete(ctx context.Context, obj *AutoBlog) (int64, error) {
	return m.DeleteByPrimaryKey(ctx, obj.Id)
}

func (m *_AutoBlogDBMgr) DeleteByPrimaryKey(ctx context.Context, _id int64) (int64, error) {
	pk := &IdOfAutoBlogPK{
		Id: _id,
	}
	q := fmt.Sprintf("DELETE FROM auto_blogs %s", pk.SQLFormat())
	result, err := m.db.Exec(ctx, q, pk.SQLParams()...)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

func (m *_AutoBlogDBMgr) DeleteBySQL(ctx context.Context, where string, args ...interface{}) (int64, error) {
	query := "DELETE FROM auto_blogs"
	if where != "" {
		query = fmt.Sprintf("DELETE FROM auto_blogs WHERE %s", where)
	}
	result, err := m.db.Exec(ctx, query, args...)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
