// Package mysqlr is generated by ezorm (v2)
// DO NOT EDIT
package mysqlr

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/ezbuy/ezorm/v2/pkg/orm"

	validator "gopkg.in/go-playground/validator.v9"
)

var (
	_ sql.DB
	_ time.Time
	_ fmt.Formatter
	_ strings.Reader
	_ validator.Validate
	_ context.Context
)

type Inventory struct {
	Id                int64  `mysql:"id"`
	WarehouseId       int64  `mysql:"warehouse_id"`
	BinId             int64  `mysql:"bin_id"`
	SkuCode           string `mysql:"sku_code"`
	Barcode           string `mysql:"barcode"`
	QuantityTotal     int64  `mysql:"quantity_total"`
	QuantityAvailable int64  `mysql:"quantity_available"`
	QuantityLocked    int64  `mysql:"quantity_locked"`
	CreateAt          int64  `mysql:"create_at"`
	UpdateAt          int64  `mysql:"update_at"`
	CreateBy          string `mysql:"create_by"`
	UpdateBy          string `mysql:"update_by"`
}

var InventoryColumns = struct {
	Id                string
	WarehouseId       string
	BinId             string
	SkuCode           string
	Barcode           string
	QuantityTotal     string
	QuantityAvailable string
	QuantityLocked    string
	CreateAt          string
	UpdateAt          string
	CreateBy          string
	UpdateBy          string
}{
	"id",
	"warehouse_id",
	"bin_id",
	"sku_code",
	"barcode",
	"quantity_total",
	"quantity_available",
	"quantity_locked",
	"create_at",
	"update_at",
	"create_by",
	"update_by",
}

type _InventoryMgr struct {
}

var InventoryMgr *_InventoryMgr

func (m *_InventoryMgr) NewInventory() *Inventory {
	return &Inventory{}
}

func (obj *Inventory) GetNameSpace() string {
	return "mysqlr_e2e"
}

func (obj *Inventory) GetClassName() string {
	return "Inventory"
}

func (obj *Inventory) GetTableName() string {
	return "oper_inventory"
}

func (obj *Inventory) GetColumns() []string {
	columns := []string{
		"oper_inventory.id",
		"oper_inventory.warehouse_id",
		"oper_inventory.bin_id",
		"oper_inventory.sku_code",
		"oper_inventory.barcode",
		"oper_inventory.quantity_total",
		"oper_inventory.quantity_available",
		"oper_inventory.quantity_locked",
		"oper_inventory.create_at",
		"oper_inventory.update_at",
		"oper_inventory.create_by",
		"oper_inventory.update_by",
	}
	return columns
}

func (obj *Inventory) GetNoneIncrementColumns() []string {
	columns := []string{
		"warehouse_id",
		"bin_id",
		"sku_code",
		"barcode",
		"quantity_total",
		"quantity_available",
		"quantity_locked",
		"create_at",
		"update_at",
		"create_by",
		"update_by",
	}
	return columns
}

func (obj *Inventory) GetPrimaryKey() PrimaryKey {
	pk := InventoryMgr.NewPrimaryKey()
	pk.Id = obj.Id
	return pk
}

func (obj *Inventory) Validate() error {
	validate := validator.New()
	return validate.Struct(obj)
}

type IdOfInventoryPK struct {
	Id int64
}

func (m *_InventoryMgr) NewPrimaryKey() *IdOfInventoryPK {
	return &IdOfInventoryPK{}
}

func (u *IdOfInventoryPK) Key() string {
	strs := []string{
		"Id",
		fmt.Sprint(u.Id),
	}
	return strings.Join(strs, ":")
}

func (u *IdOfInventoryPK) Parse(key string) error {
	arr := strings.Split(key, ":")
	if len(arr)%2 != 0 {
		return fmt.Errorf("key (%s) format error", key)
	}
	kv := map[string]string{}
	for i := 0; i < len(arr)/2; i++ {
		kv[arr[2*i]] = arr[2*i+1]
	}
	vId, ok := kv["Id"]
	if !ok {
		return fmt.Errorf("key (%s) without (Id) field", key)
	}
	if err := orm.StringScan(vId, &(u.Id)); err != nil {
		return err
	}
	return nil
}

func (u *IdOfInventoryPK) SQLFormat() string {
	conditions := []string{
		"id = ?",
	}
	return orm.SQLWhere(conditions)
}

func (u *IdOfInventoryPK) SQLParams() []interface{} {
	return []interface{}{
		u.Id,
	}
}

func (u *IdOfInventoryPK) Columns() []string {
	return []string{
		"id",
	}
}

type WarehouseIdBinIdBarcodeOfInventoryIDX struct {
	WarehouseId int64
	BinId       int64
	Barcode     string
	offset      int
	limit       int
}

func (u *WarehouseIdBinIdBarcodeOfInventoryIDX) Key() string {
	strs := []string{
		"WarehouseId",
		fmt.Sprint(u.WarehouseId),
		"BinId",
		fmt.Sprint(u.BinId),
		"Barcode",
		fmt.Sprint(u.Barcode),
	}
	return strings.Join(strs, ":")
}

func (u *WarehouseIdBinIdBarcodeOfInventoryIDX) SQLFormat(limit bool) string {
	conditions := []string{
		"warehouse_id = ?",
		"bin_id = ?",
		"barcode = ?",
	}
	if limit {
		return fmt.Sprintf("%s %s", orm.SQLWhere(conditions), orm.SQLOffsetLimit(u.offset, u.limit))
	}
	return orm.SQLWhere(conditions)
}

func (u *WarehouseIdBinIdBarcodeOfInventoryIDX) SQLParams() []interface{} {
	return []interface{}{
		u.WarehouseId,
		u.BinId,
		u.Barcode,
	}
}

func (u *WarehouseIdBinIdBarcodeOfInventoryIDX) SQLLimit() int {
	if u.limit > 0 {
		return u.limit
	}
	return -1
}

func (u *WarehouseIdBinIdBarcodeOfInventoryIDX) Limit(n int) {
	u.limit = n
}

func (u *WarehouseIdBinIdBarcodeOfInventoryIDX) Offset(n int) {
	u.offset = n
}

func (u *WarehouseIdBinIdBarcodeOfInventoryIDX) PositionOffsetLimit(len int) (int, int) {
	if u.limit <= 0 {
		return 0, len
	}
	if u.offset+u.limit > len {
		return u.offset, len
	}
	return u.offset, u.limit
}

type UpdateAtOfInventoryIDX struct {
	UpdateAt int64
	offset   int
	limit    int
}

func (u *UpdateAtOfInventoryIDX) Key() string {
	strs := []string{
		"UpdateAt",
		fmt.Sprint(u.UpdateAt),
	}
	return strings.Join(strs, ":")
}

func (u *UpdateAtOfInventoryIDX) SQLFormat(limit bool) string {
	conditions := []string{
		"update_at = ?",
	}
	if limit {
		return fmt.Sprintf("%s %s", orm.SQLWhere(conditions), orm.SQLOffsetLimit(u.offset, u.limit))
	}
	return orm.SQLWhere(conditions)
}

func (u *UpdateAtOfInventoryIDX) SQLParams() []interface{} {
	return []interface{}{
		u.UpdateAt,
	}
}

func (u *UpdateAtOfInventoryIDX) SQLLimit() int {
	if u.limit > 0 {
		return u.limit
	}
	return -1
}

func (u *UpdateAtOfInventoryIDX) Limit(n int) {
	u.limit = n
}

func (u *UpdateAtOfInventoryIDX) Offset(n int) {
	u.offset = n
}

func (u *UpdateAtOfInventoryIDX) PositionOffsetLimit(len int) (int, int) {
	if u.limit <= 0 {
		return 0, len
	}
	if u.offset+u.limit > len {
		return u.offset, len
	}
	return u.offset, u.limit
}

type _InventoryDBMgr struct {
	db orm.DB
}

func (m *_InventoryMgr) DB(db orm.DB) *_InventoryDBMgr {
	return InventoryDBMgr(db)
}

func InventoryDBMgr(db orm.DB) *_InventoryDBMgr {
	if db == nil {
		panic(fmt.Errorf("InventoryDBMgr init need db"))
	}
	return &_InventoryDBMgr{db: db}
}

func (m *_InventoryDBMgr) Search(ctx context.Context, where string, orderby string, limit string, args ...interface{}) ([]*Inventory, error) {
	obj := InventoryMgr.NewInventory()

	if limit = strings.ToUpper(strings.TrimSpace(limit)); limit != "" && !strings.HasPrefix(limit, "LIMIT") {
		limit = "LIMIT " + limit
	}

	conditions := []string{where, orderby, limit}
	query := fmt.Sprintf("SELECT %s FROM oper_inventory %s", strings.Join(obj.GetColumns(), ","), strings.Join(conditions, " "))
	return m.FetchBySQL(ctx, query, args...)
}

func (m *_InventoryDBMgr) SearchConditions(ctx context.Context, conditions []string, orderby string, offset int, limit int, args ...interface{}) ([]*Inventory, error) {
	obj := InventoryMgr.NewInventory()
	q := fmt.Sprintf("SELECT %s FROM oper_inventory %s %s %s",
		strings.Join(obj.GetColumns(), ","),
		orm.SQLWhere(conditions),
		orderby,
		orm.SQLOffsetLimit(offset, limit))

	return m.FetchBySQL(ctx, q, args...)
}

func (m *_InventoryDBMgr) SearchCount(ctx context.Context, where string, args ...interface{}) (int64, error) {
	return m.queryCount(ctx, where, args...)
}

func (m *_InventoryDBMgr) SearchConditionsCount(ctx context.Context, conditions []string, args ...interface{}) (int64, error) {
	return m.queryCount(ctx, orm.SQLWhere(conditions), args...)
}

func (m *_InventoryDBMgr) FetchBySQL(ctx context.Context, q string, args ...interface{}) (results []*Inventory, err error) {
	rows, err := m.db.Query(ctx, q, args...)
	if err != nil {
		return nil, fmt.Errorf("Inventory fetch error: %v", err)
	}
	defer rows.Close()

	for rows.Next() {
		var result Inventory
		err = rows.Scan(&(result.Id), &(result.WarehouseId), &(result.BinId), &(result.SkuCode), &(result.Barcode), &(result.QuantityTotal), &(result.QuantityAvailable), &(result.QuantityLocked), &(result.CreateAt), &(result.UpdateAt), &(result.CreateBy), &(result.UpdateBy))
		if err != nil {
			m.db.SetError(err)
			return nil, err
		}

		results = append(results, &result)
	}
	if err = rows.Err(); err != nil {
		m.db.SetError(err)
		return nil, fmt.Errorf("Inventory fetch result error: %v", err)
	}
	return
}
func (m *_InventoryDBMgr) Exist(ctx context.Context, pk PrimaryKey) (bool, error) {
	c, err := m.queryCount(ctx, pk.SQLFormat(), pk.SQLParams()...)
	if err != nil {
		return false, err
	}
	return (c != 0), nil
}

// FetchByPrimaryKey fetches a single Inventory by its primary key
// it returns the specific error type(sql.ErrNoRows) when no rows found
func (m *_InventoryDBMgr) FetchByPrimaryKey(ctx context.Context, _id int64) (*Inventory, error) {
	obj := InventoryMgr.NewInventory()
	pk := &IdOfInventoryPK{
		Id: _id,
	}

	query := fmt.Sprintf("SELECT %s FROM oper_inventory %s", strings.Join(obj.GetColumns(), ","), pk.SQLFormat())
	objs, err := m.FetchBySQL(ctx, query, pk.SQLParams()...)
	if err != nil {
		return nil, err
	}
	if len(objs) > 0 {
		return objs[0], nil
	}
	return nil, sql.ErrNoRows
}

// err not found check
func (m *_InventoryDBMgr) IsErrNotFound(err error) bool {
	return strings.Contains(err.Error(), "not found") || errors.Is(err, sql.ErrNoRows)
}

// FetchByPrimaryKeys fetches a list of Inventory by its primary keys
// it returns the specific error type(sql.ErrNoRows) when no rows found
func (m *_InventoryDBMgr) FetchByPrimaryKeys(ctx context.Context, _ids []int64) ([]*Inventory, error) {
	size := len(_ids)
	if size == 0 {
		return nil, nil
	}
	params := make([]interface{}, 0, size)
	for _, pk := range _ids {
		params = append(params, pk)
	}
	obj := InventoryMgr.NewInventory()
	query := fmt.Sprintf("SELECT %s FROM oper_inventory WHERE id IN (?%s)", strings.Join(obj.GetColumns(), ","),
		strings.Repeat(",?", size-1))
	objs, err := m.FetchBySQL(ctx, query, params...)
	if err != nil {
		return nil, err
	}
	if len(objs) == 0 {
		return nil, sql.ErrNoRows
	}
	return objs, nil
}

// indexes

func (m *_InventoryDBMgr) FindByWarehouseIdBinIdBarcode(ctx context.Context, _warehouseId int64, _binId int64, _barcode string, limit int, offset int) ([]*Inventory, error) {
	obj := InventoryMgr.NewInventory()
	idx_ := &WarehouseIdBinIdBarcodeOfInventoryIDX{
		WarehouseId: _warehouseId,
		BinId:       _binId,
		Barcode:     _barcode,
		limit:       limit,
		offset:      offset,
	}
	query := fmt.Sprintf("SELECT %s FROM oper_inventory %s", strings.Join(obj.GetColumns(), ","), idx_.SQLFormat(true))
	return m.FetchBySQL(ctx, query, idx_.SQLParams()...)
}

func (m *_InventoryDBMgr) FindAllByWarehouseIdBinIdBarcode(ctx context.Context, _warehouseId int64, _binId int64, _barcode string) ([]*Inventory, error) {
	obj := InventoryMgr.NewInventory()
	idx_ := &WarehouseIdBinIdBarcodeOfInventoryIDX{
		WarehouseId: _warehouseId,
		BinId:       _binId,
		Barcode:     _barcode,
	}

	query := fmt.Sprintf("SELECT %s FROM oper_inventory %s", strings.Join(obj.GetColumns(), ","), idx_.SQLFormat(true))
	return m.FetchBySQL(ctx, query, idx_.SQLParams()...)
}

func (m *_InventoryDBMgr) FindByUpdateAt(ctx context.Context, _updateAt int64, limit int, offset int) ([]*Inventory, error) {
	obj := InventoryMgr.NewInventory()
	idx_ := &UpdateAtOfInventoryIDX{
		UpdateAt: _updateAt,
		limit:    limit,
		offset:   offset,
	}
	query := fmt.Sprintf("SELECT %s FROM oper_inventory %s", strings.Join(obj.GetColumns(), ","), idx_.SQLFormat(true))
	return m.FetchBySQL(ctx, query, idx_.SQLParams()...)
}

func (m *_InventoryDBMgr) FindAllByUpdateAt(ctx context.Context, _updateAt int64) ([]*Inventory, error) {
	obj := InventoryMgr.NewInventory()
	idx_ := &UpdateAtOfInventoryIDX{
		UpdateAt: _updateAt,
	}

	query := fmt.Sprintf("SELECT %s FROM oper_inventory %s", strings.Join(obj.GetColumns(), ","), idx_.SQLFormat(true))
	return m.FetchBySQL(ctx, query, idx_.SQLParams()...)
}

func (m *_InventoryDBMgr) FindByUpdateAtGroup(ctx context.Context, items []int64) ([]*Inventory, error) {
	obj := InventoryMgr.NewInventory()
	if len(items) == 0 {
		return nil, nil
	}
	params := make([]interface{}, 0, len(items))
	for _, item := range items {
		params = append(params, item)
	}
	query := fmt.Sprintf("SELECT %s FROM oper_inventory where update_at in (?", strings.Join(obj.GetColumns(), ",")) +
		strings.Repeat(",?", len(items)-1) + ")"
	return m.FetchBySQL(ctx, query, params...)
}

// uniques

func (m *_InventoryDBMgr) FindOne(ctx context.Context, unique Unique) (PrimaryKey, error) {
	objs, err := m.queryLimit(ctx, unique.SQLFormat(true), unique.SQLLimit(), unique.SQLParams()...)
	if err != nil {
		return nil, err
	}
	if len(objs) > 0 {
		return objs[0], nil
	}
	return nil, fmt.Errorf("Inventory find record not found")
}

func (m *_InventoryDBMgr) FindFetch(ctx context.Context, index Index) (int64, []*Inventory, error) {
	total, err := m.queryCount(ctx, index.SQLFormat(false), index.SQLParams()...)
	if err != nil {
		return total, nil, err
	}

	obj := InventoryMgr.NewInventory()
	query := fmt.Sprintf("SELECT %s FROM oper_inventory %s", strings.Join(obj.GetColumns(), ","), index.SQLFormat(true))
	results, err := m.FetchBySQL(ctx, query, index.SQLParams()...)
	if err != nil {
		return total, nil, err
	}
	return total, results, nil
}

func (m *_InventoryDBMgr) queryLimit(ctx context.Context, where string, limit int, args ...interface{}) (results []PrimaryKey, err error) {
	pk := InventoryMgr.NewPrimaryKey()
	query := fmt.Sprintf("SELECT %s FROM oper_inventory %s", strings.Join(pk.Columns(), ","), where)
	rows, err := m.db.Query(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("Inventory query limit error: %v", err)
	}
	defer rows.Close()

	offset := 0

	for rows.Next() {
		if limit >= 0 && offset >= limit {
			break
		}
		offset++

		result := InventoryMgr.NewPrimaryKey()
		err = rows.Scan(&(result.Id))
		if err != nil {
			m.db.SetError(err)
			return nil, err
		}

		results = append(results, result)
	}
	if err := rows.Err(); err != nil {
		m.db.SetError(err)
		return nil, fmt.Errorf("Inventory query limit result error: %v", err)
	}
	return
}

func (m *_InventoryDBMgr) queryCount(ctx context.Context, where string, args ...interface{}) (int64, error) {
	query := fmt.Sprintf("SELECT count( id ) FROM oper_inventory %s", where)
	rows, err := m.db.Query(ctx, query, args...)
	if err != nil {
		return 0, fmt.Errorf("Inventory query count error: %v", err)
	}
	defer rows.Close()

	var count int64
	if rows.Next() {
		if err = rows.Scan(&count); err != nil {
			m.db.SetError(err)
			return 0, err
		}
	}
	return count, nil
}

func (m *_InventoryDBMgr) BatchCreate(ctx context.Context, objs []*Inventory) (int64, error) {
	if len(objs) == 0 {
		return 0, nil
	}

	params := make([]string, 0, len(objs))
	values := make([]interface{}, 0, len(objs)*11)
	for _, obj := range objs {
		params = append(params, fmt.Sprintf("(%s)", strings.Join(orm.NewStringSlice(11, "?"), ",")))
		values = append(values, obj.WarehouseId)
		values = append(values, obj.BinId)
		values = append(values, obj.SkuCode)
		values = append(values, obj.Barcode)
		values = append(values, obj.QuantityTotal)
		values = append(values, obj.QuantityAvailable)
		values = append(values, obj.QuantityLocked)
		values = append(values, obj.CreateAt)
		values = append(values, obj.UpdateAt)
		values = append(values, obj.CreateBy)
		values = append(values, obj.UpdateBy)
	}
	query := fmt.Sprintf("INSERT INTO oper_inventory(%s) VALUES %s", strings.Join(objs[0].GetNoneIncrementColumns(), ","), strings.Join(params, ","))
	result, err := m.db.Exec(ctx, query, values...)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

// argument example:
// set:"a=?, b=?"
// where:"c=? and d=?"
// params:[]interface{}{"a", "b", "c", "d"}...
func (m *_InventoryDBMgr) UpdateBySQL(ctx context.Context, set, where string, args ...interface{}) (int64, error) {
	query := fmt.Sprintf("UPDATE oper_inventory SET %s", set)
	if where != "" {
		query = fmt.Sprintf("UPDATE oper_inventory SET %s WHERE %s", set, where)
	}
	result, err := m.db.Exec(ctx, query, args...)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

func (m *_InventoryDBMgr) Create(ctx context.Context, obj *Inventory) (int64, error) {
	params := orm.NewStringSlice(11, "?")
	q := fmt.Sprintf("INSERT INTO oper_inventory(%s) VALUES(%s)",
		strings.Join(obj.GetNoneIncrementColumns(), ","),
		strings.Join(params, ","))

	values := make([]interface{}, 0, 12)
	values = append(values, obj.WarehouseId)
	values = append(values, obj.BinId)
	values = append(values, obj.SkuCode)
	values = append(values, obj.Barcode)
	values = append(values, obj.QuantityTotal)
	values = append(values, obj.QuantityAvailable)
	values = append(values, obj.QuantityLocked)
	values = append(values, obj.CreateAt)
	values = append(values, obj.UpdateAt)
	values = append(values, obj.CreateBy)
	values = append(values, obj.UpdateBy)
	result, err := m.db.Exec(ctx, q, values...)
	if err != nil {
		return 0, err
	}
	lastInsertId, err := result.LastInsertId()
	if err != nil {
		return 0, err
	}
	obj.Id = int64(lastInsertId)
	return result.RowsAffected()
}

func (m *_InventoryDBMgr) Update(ctx context.Context, obj *Inventory) (int64, error) {
	columns := []string{
		"warehouse_id = ?",
		"bin_id = ?",
		"sku_code = ?",
		"barcode = ?",
		"quantity_total = ?",
		"quantity_available = ?",
		"quantity_locked = ?",
		"create_at = ?",
		"update_at = ?",
		"create_by = ?",
		"update_by = ?",
	}

	pk := obj.GetPrimaryKey()
	q := fmt.Sprintf("UPDATE oper_inventory SET %s %s", strings.Join(columns, ","), pk.SQLFormat())
	values := make([]interface{}, 0, 12-1)
	values = append(values, obj.WarehouseId)
	values = append(values, obj.BinId)
	values = append(values, obj.SkuCode)
	values = append(values, obj.Barcode)
	values = append(values, obj.QuantityTotal)
	values = append(values, obj.QuantityAvailable)
	values = append(values, obj.QuantityLocked)
	values = append(values, obj.CreateAt)
	values = append(values, obj.UpdateAt)
	values = append(values, obj.CreateBy)
	values = append(values, obj.UpdateBy)
	values = append(values, pk.SQLParams()...)

	result, err := m.db.Exec(ctx, q, values...)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

func (m *_InventoryDBMgr) Save(ctx context.Context, obj *Inventory) (int64, error) {
	affected, err := m.Update(ctx, obj)
	if err != nil {
		return affected, err
	}
	if affected == 0 {
		return m.Create(ctx, obj)
	}
	return affected, err
}

func (m *_InventoryDBMgr) Delete(ctx context.Context, obj *Inventory) (int64, error) {
	return m.DeleteByPrimaryKey(ctx, obj.Id)
}

func (m *_InventoryDBMgr) DeleteByPrimaryKey(ctx context.Context, _id int64) (int64, error) {
	pk := &IdOfInventoryPK{
		Id: _id,
	}
	q := fmt.Sprintf("DELETE FROM oper_inventory %s", pk.SQLFormat())
	result, err := m.db.Exec(ctx, q, pk.SQLParams()...)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

func (m *_InventoryDBMgr) DeleteBySQL(ctx context.Context, where string, args ...interface{}) (int64, error) {
	query := "DELETE FROM oper_inventory"
	if where != "" {
		query = fmt.Sprintf("DELETE FROM oper_inventory WHERE %s", where)
	}
	result, err := m.db.Exec(ctx, query, args...)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
