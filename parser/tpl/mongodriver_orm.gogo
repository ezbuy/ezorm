{{define "mongodriver_orm"}}package {{.GoPackage}}
{{$obj := .}}

{{if ($obj.DbSwitch "mongodriver")}}
import (
    "context"

    "github.com/ezbuy/ezorm/orm"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

func init() {
    orm.RegisterEzOrmObjByID("{{.Package}}", "{{.Name}}", new{{.Name}}FindByID)
	orm.RegisterEzOrmObjRemove("{{.Package}}", "{{.Name}}", {{.Name}}Mgr.RemoveByID)
}

func new{{.Name}}FindByID(id string) (result orm.EzOrmObj, err error) {
	return {{.Name}}Mgr.FindByID(id)
}

// =====================================
// INSERT METHODS
// =====================================

var (
    insert{{.Name}}CBs []func(obj orm.EzOrmObj)
    update{{.Name}}CBs []func(obj orm.EzOrmObj)
)

func {{.Name}}AddInsertCallback(cb func(obj orm.EzOrmObj)) {
    insert{{.Name}}CBs = append(insert{{.Name}}CBs, cb)
}

func {{.Name}}AddUpdateCallback(cb func(obj orm.EzOrmObj)) {
    update{{.Name}}CBs = append(update{{.Name}}CBs, cb)
}

func (o *{{.Name}}) Id() string {
    return o.ID.Hex()
}

func (o *{{.Name}}) Save() (*mongo.UpdateResult, error) {
    isNew := o.isNew

	{{range $field := .Fields}}
	{{if and (ne $field.Name "ID") $field.HasMeta}}
	{{$field.Name}}_old_metas, _ := o.GetAll{{$field.Meta}}()
	{{$field.Name}}_new_metas, _ := {{$field.Meta}}FindByIDs(o.{{$field.Name}})
	for _, meta := range {{$field.Name}}_old_metas {
		{{$field.Meta}}RemoveByID(meta.ID.Hex())
	}
	for _, meta := range {{$field.Name}}_new_metas {
		meta.Save()
	}
	{{end}}
	{{end}}
    
    filter := bson.M{"_id": o.ID}
    update := bson.M{
        "$set": bson.M{
        {{- range $field := .Fields}}
            {{$obj.Name}}MgoField{{$field.Name}}: o.{{$field.Name}},
        {{- end}}
        },
    }

    opts := options.Update().SetUpsert(true)
    col := {{.Name}}Mgr.GetCol()
    ret, err := col.UpdateOne(context.TODO(), filter, update, opts)
    if err != nil {
        return ret, err
    }
    
    o.isNew = false
    if isNew {
        {{.Name}}InsertCallback(o)
    } else {
        {{.Name}}UpdateCallback(o)
    }
    return ret, err
}

func (o *{{.Name}}) InsertUnique(query interface{}) (saved bool, err error) {
    update := bson.M{
        "$setOnInsert": bson.M{
        {{- range $field := .Fields}}
            {{$obj.Name}}MgoField{{$field.Name}}: o.{{$field.Name}},
        {{- end}}
        },
    }

    opts := options.Update().SetUpsert(true)
    col := {{.Name}}Mgr.GetCol()
    ret, err := col.UpdateOne(context.TODO(), query, update, opts)
    if err != nil {
        return false, err
    }
    if ret.UpsertedCount == 0 {
        saved = true
    }

    o.isNew = false
    if saved {
        {{.Name}}InsertCallback(o)
    }
    return saved, nil
}

func {{.Name}}InsertCallback(o *{{.Name}}) {
    for _, cb := range insert{{.Name}}CBs {
        cb(o)
    }
}

func {{.Name}}UpdateCallback(o *{{.Name}}) {
    for _, cb := range update{{.Name}}CBs {
        cb(o)
    }
}


// =====================================
// FOREIGN KEYS
// =====================================

{{range $field := $obj.Fields}}
{{if $field.HasForeign}}
func (p *{{$obj.Name}}) Get{{$field.Foreign}}() (result *{{$field.ForeignType}}, err error) {
    return {{$field.ForeignType}}Mgr.FindByID(p.{{$field.Name}})
}

func (p *{{$obj.Name}}) Set{{$field.Foreign}}(obj *{{$field.ForeignType}}) {
    p.{{$field.Name}} = obj.ID.Hex()
}

{{if eq $field.Foreign $field.ForeignType}}
func (o *{{$field.Foreign}}) GetAll{{$obj.Name}}() (result []*{{$obj.Name}}, err error) {
	query := bson.M{"{{$field.Foreign}}ID": o.ID.Hex()}
    return {{$obj.Name}}Mgr.FindAll(query)
}

func (o *{{$field.Foreign}}) Count{{$obj.Name}}() (count int) {
	query := bson.M{"{{$field.Foreign}}ID": o.ID.Hex()}
	return {{$obj.Name}}Mgr.Count(query)
}

func (o *{{$field.Foreign}}) Find{{$obj.Name}}(limit, offset int, sortFields interface{}) (result []*{{$obj.Name}}, err error) {
	query := bson.M{"{{$field.Foreign}}ID": o.ID.Hex()}
	return {{$obj.Name}}Mgr.Find(query, limit, offset, sortFields)
}

{{end -}}
{{end -}}
{{end -}}


// =====================================
// COLLECTION
// =====================================

func (o *_{{.Name}}Mgr) FindOne(query interface{}, sortFields interface{}) (result *{{$obj.Name}}, err error) {
    col := o.GetCol()
    opts := options.FindOne()

    if sortFields != nil {
        opts.SetSort(sortFields)
    }

    ret := col.FindOne(context.TODO(), query, opts)
    if err = ret.Err(); err != nil {
        return nil, err
    }
    err = ret.Decode(&result)
    return
}

func (o *_{{.Name}}Mgr) Query(query interface{}, limit, offset int, sortFields interface{}) (*mongo.Cursor, error) {
    col := o.GetCol()
    opts := options.Find()

    if limit > 0 {
        opts.SetLimit(int64(limit))
    }
    if offset > 0 {
        opts.SetLimit(int64(offset))
    }
    if sortFields != nil {
        opts.SetSort(sortFields)
    }

    return col.Find(context.TODO(), query, opts)
}

{{- range $index := $obj.Indexes}}
{{- if $index.IsUnique}}

func (o *_{{$obj.Name}}Mgr) FindOneBy{{$index.Name}}({{$index.GetFuncParam}}) (result *{{$obj.Name}}, err error) {
	query := bson.M{
		{{- range $field := $index.Fields}}
		"{{$field.Name}}": {{$field.Name}},
		{{- end}}
	}
    return o.FindOne(query, nil)
}

// MustFindOneBy{{$index.Name}} only use it when you should not trust the query result
func (o *_{{$obj.Name}}Mgr) MustFindOneBy{{$index.Name}}({{$index.GetFuncParam}}) (result *{{$obj.Name}}) {
    result, _ = o.FindOneBy{{$index.Name}}({{$index.GetFuncParamNames}})
    if result == nil {
        result = o.New{{$obj.Name}}()
		{{- range $field := $index.Fields}}
		result.{{$field.Name}} = {{$field.Name}}
		{{- end}}
		result.Save()
    }
    return
}

func (o *_{{$obj.Name}}Mgr) RemoveBy{{$index.Name}}({{$index.GetFuncParam}}) (err error) {
    col := o.GetCol()

	query := bson.M{
		{{- range $field := $index.Fields}}
		"{{$field.Name}}": {{$field.Name}},
		{{- end}}
	}
	_, err = col.DeleteOne(context.TODO(), query)
    return err
}

{{- else}}

func (o *_{{$obj.Name}}Mgr) FindBy{{$index.Name}}({{$index.GetFuncParam}}, limit int, offset int, sortFields interface{}) (result []*{{$obj.Name}}, err error) {
	query := bson.M{
		{{- range $field := $index.Fields}}
		"{{$field.Name}}": {{$field.Name}},
		{{- end}}
	}
	cursor, err := o.Query(query, limit, offset, sortFields)
    if err != nil {
        return nil, err
    }
    err = cursor.All(context.TODO(), &result)
    return
}

{{end -}}
{{end -}}

func (o *_{{.Name}}Mgr) Find(query interface{}, limit int, offset int, sortFields interface{}) (result []*{{$obj.Name}}, err error) {
    cursor, err := o.Query(query, limit, offset, sortFields)
    if err != nil {
        return nil, err
    }
    err = cursor.All(context.TODO(), &result)
    return
}

func (o *_{{.Name}}Mgr) FindAll(query interface{}, sortFields interface{}) (result []*{{$obj.Name}}, err error) {
    cursor, err := o.Query(query, -1, -1, sortFields)
    if err != nil {
        return nil, err
    }
    err = cursor.All(context.TODO(), &result)
    return
}

func (o *_{{.Name}}Mgr) Has(query interface{}) bool {
    count, err := o.CountE(query)
    if err != nil || count == 0 {
        return false
    }
    return true
}

func (o *_{{.Name}}Mgr) Count(query interface{}) int {
    count, _ := o.CountE(query)
    return count
}

func (o *_{{.Name}}Mgr) CountE(query interface{}) (int, error) {
    col := o.GetCol()
    count, err := col.CountDocuments(context.TODO(), query)
    return int(count), err
}

func (o *_{{.Name}}Mgr) FindByIDs(id []string, sortFields interface{}) (result []*{{$obj.Name}}, err error) {
	ids := make([]primitive.ObjectID, 0, len(id))
	for _, i := range id {
		if oid, err := primitive.ObjectIDFromHex(i); err == nil {
			ids = append(ids, oid)
		}
	}
    return o.FindAll(bson.M{"_id": bson.M{"$in": ids}}, sortFields)
}

func (o *_{{.Name}}Mgr) FindByID(id string) (result *{{$obj.Name}}, err error) {
    oid, err := primitive.ObjectIDFromHex(id)
    if err != nil {
        return nil, mongo.ErrNoDocuments
    }

    col := o.GetCol()
    ret := col.FindOne(context.TODO(), bson.M{"_id": oid})
    if err = ret.Err(); err != nil {
        return nil, err
    }
    err = ret.Decode(&result)
    return
}

func (o *_{{.Name}}Mgr) RemoveAll(query interface{}) (int64, error) {
    if query == nil {
        query = bson.M{}
    }

    col := o.GetCol()
    ret, err := col.DeleteMany(context.TODO(), query)
    if err != nil {
        return 0, err
    }
    return ret.DeletedCount, nil
}

func (o *_{{.Name}}Mgr) RemoveByID(id string) (err error) {
    oid, err := primitive.ObjectIDFromHex(id)
    if err != nil {
        return mongo.ErrNoDocuments
    }

    col := o.GetCol()
    _, err = col.DeleteOne(context.TODO(), bson.M{"_id": oid})
    return err
}

func (m *_{{.Name}}Mgr) GetCol() *mongo.Collection {
    return Col({{if eq .Table ""}}"{{.Package}}.{{.Name}}"{{else}}"{{.Table}}"{{end}})
}

{{end}}
{{end}}
