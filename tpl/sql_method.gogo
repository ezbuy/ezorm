{{define "sql_method"}}// Package {{.GoPackage}} is generated from {{.Dir}} directory
// by github.com/ezbuy/ezorm/v2 , DO NOT EDIT!
package {{.GoPackage}}

import (
	"time"
	"context"

	"github.com/ezbuy/ezorm/v2/db"
)

var (
	_ time.Time
	_ context.Context
)

type sqlMethods struct {}

var SQL = &sqlMethods{}

{{- range $method := .Methods}}
type {{$method.Name}}Resp struct {
	{{- range $field := $method.Result}}
	{{$field.Name}} {{$field.Type}} `sql:"{{$field.Raw}}"`
	{{- end -}}
}

type {{$method.Name}}Req struct {
	{{- range $field := $method.Fields}}
	{{$field.Name}} {{$field.Type}} `sql:"{{$field.Raw}}"`
	{{- end -}}
}

func (req *{{$method.Name}}Req) Params() []any {
	return []any{
		{{- range $field := $method.Fields}}
		req.{{$field.Name}},
		{{- end -}}
	}
}

const _{{$method.Name}}SQL = "{{$method.SQL}}"

// {{$method.Name}} is a raw query handler generated function for `{{$.Dir}}/{{$method.FromFile}}`.
func (*sqlMethods) {{$method.Name}}(ctx context.Context, req *{{$method.Name}}Req ) ([]*{{$method.Name}}Resp, error) {
	rows, err := db.MysqlQuery(_{{$method.Name}}SQL, req.Params()...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*{{$method.Name}}Resp
	for rows.Next() {
		var o {{$method.Name}}Resp
		err = rows.Scan({{$method.Assign}})
		if err != nil {
			return nil, err
		}
		results = append(results, &o)
	}
	return results, nil
}
{{- end}}

{{- end -}}
